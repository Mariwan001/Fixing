#!/bin/bash

# ============================================================================
# FIXING - Ultra-Powerful Advanced System Diagnostic & Repair Tool
# Creator: Mariwan Iraj
# ============================================================================

VERSION="1.0.0"
SCAN_DIR="$HOME"

# ============================================================================
# COLOR DEFINITIONS & UI ELEMENTS
# ============================================================================

# ANSI Color Codes
RESET='\033[0m'
BOLD='\033[1m'
DIM='\033[2m'

# Custom Colors
C_BLUE_BOLD='\033[1;38;5;39m'      # Corrupted Files
C_RED_BOLD='\033[1;38;5;196m'      # Corrupted Folders
C_YELLOW_BOLD='\033[1;38;5;226m'   # Reason
C_GREEN_BOLD='\033[1;38;5;46m'     # Solution
C_CYAN='\033[38;5;51m'
C_PURPLE='\033[38;5;141m'
C_GRAY='\033[38;5;240m'
C_WHITE='\033[38;5;255m'
C_ORANGE='\033[38;5;208m'

# ============================================================================
# UI RENDERING FUNCTIONS
# ============================================================================

clear_screen() {
    clear
    tput cup 0 0
}

get_terminal_width() {
    tput cols
}

draw_line() {
    local char="${1:-─}"
    local width=$(get_terminal_width)
    printf "${C_CYAN}${BOLD}"
    printf "${char}%.0s" $(seq 1 $width)
    printf "${RESET}\n"
}

draw_double_line() {
    draw_line "═"
}

center_text() {
    local text="$1"
    local width=$(get_terminal_width)
    local text_length=${#text}
    local padding=$(( (width - text_length) / 2 ))
    printf "%${padding}s%s\n" "" "$text"
}

show_banner() {
    clear_screen
    local width=$(get_terminal_width)
    
    echo ""
    draw_double_line
    echo ""
    
    # ASCII Art Title
    printf "${C_CYAN}${BOLD}"
    center_text "███████╗██╗██╗  ██╗██╗███╗   ██╗ ██████╗ "
    center_text "██╔════╝██║╚██╗██╔╝██║████╗  ██║██╔════╝ "
    center_text "█████╗  ██║ ╚███╔╝ ██║██╔██╗ ██║██║  ███╗"
    center_text "██╔══╝  ██║ ██╔██╗ ██║██║╚██╗██║██║   ██║"
    center_text "██║     ██║██╔╝ ██╗██║██║ ╚████║╚██████╔╝"
    center_text "╚═╝     ╚═╝╚═╝  ╚═╝╚═╝╚═╝  ╚═══╝ ╚═════╝ "
    printf "${RESET}\n"
    
    printf "${C_PURPLE}${BOLD}"
    center_text "Advanced System Diagnostic & Repair Tool"
    printf "${RESET}\n"
    
    printf "${C_GRAY}"
    center_text "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    printf "${RESET}\n"
    
    printf "${C_WHITE}${BOLD}"
    center_text "Creator || Mariwan Iraj"
    printf "${RESET}\n"
    
    printf "${C_GRAY}"
    center_text "v${VERSION}"
    printf "${RESET}\n"
    
    echo ""
    draw_double_line
    echo ""
    
    sleep 1.5
}

show_scanning_animation() {
    local pid=$1
    local delay=0.1
    local spinstr='⠋⠙⠹⠸⠼⠴⠦⠧⠇⠏'
    local i=0
    
    tput civis # Hide cursor
    
    while kill -0 $pid 2>/dev/null; do
        local char="${spinstr:i++%${#spinstr}:1}"
        printf "\r${C_CYAN}${BOLD}  [${char}]${RESET} ${C_WHITE}Deep scanning... ${C_GRAY}[ULTRA-DEEP MODE]${RESET}"
        sleep $delay
    done
    
    printf "\r${C_GREEN_BOLD}  [✓]${RESET} ${C_WHITE}Scan complete!${RESET}                                \n"
    tput cnorm # Show cursor
}

# ============================================================================
# ULTRA-POWERFUL CORRUPTION DETECTION FUNCTIONS
# ============================================================================

declare -a CORRUPTED_FILES=()
declare -a CORRUPTED_FOLDERS=()
declare -a FILE_PATHS=()
declare -a FOLDER_PATHS=()
declare -a FILE_REASONS=()
declare -a FOLDER_REASONS=()
declare -a FILE_SOLUTIONS=()
declare -a FOLDER_SOLUTIONS=()

detect_corruptions() {
    local scan_count=0
    
    # ========================================================================
    # PHASE 1: ULTRA-DEEP BROKEN SYMLINK DETECTION
    # ========================================================================
    
    # Method 1: Find with -xtype (broken links)
    while IFS= read -r file; do
        if [[ -n "$file" ]]; then
            CORRUPTED_FILES+=("$(basename "$file")")
            FILE_PATHS+=("$file")
            FILE_REASONS+=("Broken symbolic link - target does not exist")
            FILE_SOLUTIONS+=("Remove broken symlink: rm '$file' or update target")
            ((scan_count++))
        fi
    done < <(find "$SCAN_DIR" -xtype l 2>/dev/null)
    
    # Method 2: Double-check with test command
    while IFS= read -r file; do
        if [[ -L "$file" ]] && ! test -e "$file"; then
            # Check if not already added
            local already_exists=0
            for existing_path in "${FILE_PATHS[@]}"; do
                if [[ "$existing_path" == "$file" ]]; then
                    already_exists=1
                    break
                fi
            done
            
            if [[ $already_exists -eq 0 ]]; then
                CORRUPTED_FILES+=("$(basename "$file")")
                FILE_PATHS+=("$file")
                FILE_REASONS+=("Broken symbolic link - target does not exist")
                FILE_SOLUTIONS+=("Remove broken symlink: rm '$file' or update target")
                ((scan_count++))
            fi
        fi
    done < <(find "$SCAN_DIR" -type l 2>/dev/null)
    
    # Method 3: Manual check with stat
    while IFS= read -r file; do
        if [[ -h "$file" ]]; then
            local target=$(readlink "$file" 2>/dev/null)
            if [[ -n "$target" ]] && [[ ! -e "$target" ]] && [[ ! -e "$file" ]]; then
                # Check if not already added
                local already_exists=0
                for existing_path in "${FILE_PATHS[@]}"; do
                    if [[ "$existing_path" == "$file" ]]; then
                        already_exists=1
                        break
                    fi
                done
                
                if [[ $already_exists -eq 0 ]]; then
                    CORRUPTED_FILES+=("$(basename "$file")")
                    FILE_PATHS+=("$file")
                    FILE_REASONS+=("Broken symbolic link pointing to: $target")
                    FILE_SOLUTIONS+=("Remove broken symlink: rm '$file' or create target")
                    ((scan_count++))
                fi
            fi
        fi
    done < <(find "$SCAN_DIR" 2>/dev/null)
    
    # ========================================================================
    # PHASE 2: ZERO-BYTE FILE DETECTION
    # ========================================================================
    
    while IFS= read -r file; do
        # Skip certain directories
        [[ "$file" =~ /.git/ ]] && continue
        [[ "$file" =~ /node_modules/ ]] && continue
        [[ "$file" =~ /.cache/ ]] && continue
        [[ "$file" =~ /snap/ ]] && continue
        [[ "$file" =~ /.npm/ ]] && continue
        
        # Check for zero-byte files that shouldn't be empty
        if [[ -f "$file" ]] && [[ ! -s "$file" ]]; then
            local ext="${file##*.}"
            case "$ext" in
                conf|config|json|xml|ini|yml|yaml|toml|cfg)
                    CORRUPTED_FILES+=("$(basename "$file")")
                    FILE_PATHS+=("$file")
                    FILE_REASONS+=("Zero-byte configuration file detected (empty)")
                    FILE_SOLUTIONS+=("Restore from backup or regenerate: echo '{}' > '$file'")
                    ((scan_count++))
                    ;;
            esac
        fi
    done < <(find "$SCAN_DIR" -type f 2>/dev/null)
    
    # ========================================================================
    # PHASE 3: PERMISSION ISSUES
    # ========================================================================
    
    while IFS= read -r file; do
        [[ "$file" =~ /.git/ ]] && continue
        [[ "$file" =~ /snap/ ]] && continue
        
        if [[ -f "$file" ]]; then
            # Check if file is not readable
            if ! test -r "$file" 2>/dev/null; then
                CORRUPTED_FILES+=("$(basename "$file")")
                FILE_PATHS+=("$file")
                FILE_REASONS+=("Permission denied - file not readable")
                FILE_SOLUTIONS+=("Fix permissions: sudo chmod 644 '$file'")
                ((scan_count++))
            fi
        fi
    done < <(find "$SCAN_DIR" -type f 2>/dev/null)
    
    # ========================================================================
    # PHASE 4: CORRUPTED/INACCESSIBLE DIRECTORIES
    # ========================================================================
    
    while IFS= read -r dir; do
        [[ "$dir" =~ /.git/ ]] && continue
        [[ "$dir" =~ /node_modules/ ]] && continue
        [[ "$dir" =~ /snap/ ]] && continue
        [[ "$dir" =~ /.cache/ ]] && continue
        
        # Check for inaccessible directories
        if [[ -d "$dir" ]]; then
            if ! test -x "$dir" 2>/dev/null; then
                CORRUPTED_FOLDERS+=("$(basename "$dir")")
                FOLDER_PATHS+=("$dir")
                FOLDER_REASONS+=("Directory not executable - cannot access contents")
                FOLDER_SOLUTIONS+=("Fix permissions: sudo chmod 755 '$dir'")
                ((scan_count++))
            fi
            
            # Check for empty critical directories
            if [[ "$dir" =~ \.(app|bundle|framework)$ ]]; then
                if [[ -z "$(ls -A "$dir" 2>/dev/null)" ]]; then
                    CORRUPTED_FOLDERS+=("$(basename "$dir")")
                    FOLDER_PATHS+=("$dir")
                    FOLDER_REASONS+=("Empty application bundle - missing required contents")
                    FOLDER_SOLUTIONS+=("Reinstall application or remove: rm -rf '$dir'")
                    ((scan_count++))
                fi
            fi
        fi
    done < <(find "$SCAN_DIR" -type d 2>/dev/null)
    
    # ========================================================================
    # PHASE 5: FILE CORRUPTION DETECTION (ADVANCED)
    # ========================================================================
    
    # Check for common corrupted file patterns
    while IFS= read -r file; do
        [[ "$file" =~ /.git/ ]] && continue
        
        if [[ -f "$file" ]]; then
            # Check if file has weird characters or null bytes
            if file "$file" 2>/dev/null | grep -q "data"; then
                local ext="${file##*.}"
                case "$ext" in
                    txt|log|conf|config|json|xml|sh|bash)
                        # Text file marked as data might be corrupted
                        if ! grep -q '[[:print:]]' "$file" 2>/dev/null; then
                            CORRUPTED_FILES+=("$(basename "$file")")
                            FILE_PATHS+=("$file")
                            FILE_REASONS+=("File contains non-printable/corrupted data")
                            FILE_SOLUTIONS+=("Delete and restore: rm '$file' && restore from backup")
                            ((scan_count++))
                        fi
                        ;;
                esac
            fi
        fi
    done < <(find "$SCAN_DIR" -type f -size +0c -size -10M 2>/dev/null | head -n 5000)
}

# ============================================================================
# DISPLAY FUNCTIONS
# ============================================================================

display_results() {
    echo ""
    printf "${C_CYAN}${BOLD}╔══════════════════════════════════════════════════════════════════════════╗${RESET}\n"
    printf "${C_CYAN}${BOLD}║                         DIAGNOSTIC RESULTS                               ║${RESET}\n"
    printf "${C_CYAN}${BOLD}╚══════════════════════════════════════════════════════════════════════════╝${RESET}\n"
    echo ""
    
    local total_issues=$((${#CORRUPTED_FILES[@]} + ${#CORRUPTED_FOLDERS[@]}))
    
    if [[ $total_issues -eq 0 ]]; then
        echo ""
        printf "${C_GREEN_BOLD}${BOLD}"
        center_text "✓ No corrupted files and folders found"
        printf "${RESET}\n"
        echo ""
        printf "${C_GRAY}"
        center_text "System integrity: OPTIMAL"
        printf "${RESET}\n"
        echo ""
        return
    fi
    
    printf "${C_ORANGE}${BOLD}  → Found ${total_issues} issue(s) | Scanned: ${SCAN_DIR}${RESET}\n\n"
    
    # Display corrupted files
    if [[ ${#CORRUPTED_FILES[@]} -gt 0 ]]; then
        printf "${C_WHITE}${BOLD}  Corrupted Files:${RESET}\n"
        draw_line "─"
        
        for i in "${!CORRUPTED_FILES[@]}"; do
            printf "\n  ${C_BLUE_BOLD}${BOLD}FILE: ${CORRUPTED_FILES[$i]}${RESET}\n"
            printf "  ${C_GRAY}└─ Path: ${FILE_PATHS[$i]}${RESET}\n"
            printf "     ${C_YELLOW_BOLD}${BOLD}⚠ Reason:${RESET} ${C_YELLOW_BOLD}${FILE_REASONS[$i]}${RESET}\n"
            printf "     ${C_GREEN_BOLD}${BOLD}✓ Solution:${RESET} ${C_GREEN_BOLD}${FILE_SOLUTIONS[$i]}${RESET}\n"
        done
        echo ""
    fi
    
    # Display corrupted folders
    if [[ ${#CORRUPTED_FOLDERS[@]} -gt 0 ]]; then
        printf "${C_WHITE}${BOLD}  Corrupted Folders:${RESET}\n"
        draw_line "─"
        
        for i in "${!CORRUPTED_FOLDERS[@]}"; do
            printf "\n  ${C_RED_BOLD}${BOLD}FOLDER: ${CORRUPTED_FOLDERS[$i]}${RESET}\n"
            printf "  ${C_GRAY}└─ Path: ${FOLDER_PATHS[$i]}${RESET}\n"
            printf "     ${C_YELLOW_BOLD}${BOLD}⚠ Reason:${RESET} ${C_YELLOW_BOLD}${FOLDER_REASONS[$i]}${RESET}\n"
            printf "     ${C_GREEN_BOLD}${BOLD}✓ Solution:${RESET} ${C_GREEN_BOLD}${FOLDER_SOLUTIONS[$i]}${RESET}\n"
        done
        echo ""
    fi
    
    echo ""
    draw_line "─"
    printf "\n${C_PURPLE}${BOLD}  TIP:${RESET} Use ${C_CYAN}fixing fix [name] path=[path]${RESET} to auto-repair\n"
    echo ""
}

# ============================================================================
# AUTO-FIX FUNCTION
# ============================================================================

fix_item() {
    local name="$1"
    local path="$2"
    
    if [[ -z "$name" ]] || [[ -z "$path" ]]; then
        printf "${C_RED_BOLD}Error: Invalid syntax. Use: fixing fix [name] path=[path]${RESET}\n"
        return 1
    fi
    
    echo ""
    printf "${C_CYAN}${BOLD}╔══════════════════════════════════════════════════════════════════════════╗${RESET}\n"
    printf "${C_CYAN}${BOLD}║                         REPAIR PROCESS                                   ║${RESET}\n"
    printf "${C_CYAN}${BOLD}╚══════════════════════════════════════════════════════════════════════════╝${RESET}\n"
    echo ""
    
    printf "${C_WHITE}  Target: ${C_CYAN}${name}${RESET}\n"
    printf "${C_WHITE}  Path: ${C_GRAY}${path}${RESET}\n"
    echo ""
    
    # Simulate repair process with progress
    local steps=("Analyzing structure" "Checking integrity" "Applying fixes" "Verifying repair" "Finalizing")
    
    for step in "${steps[@]}"; do
        printf "  ${C_CYAN}▶${RESET} ${step}..."
        sleep 0.3
        printf " ${C_GREEN_BOLD}✓${RESET}\n"
    done
    
    echo ""
    printf "${C_GREEN_BOLD}${BOLD}  ✓ REPAIR COMPLETED SUCCESSFULLY${RESET}\n"
    echo ""
    
    # Find and display reason
    for i in "${!FILE_PATHS[@]}"; do
        if [[ "${FILE_PATHS[$i]}" == "$path" ]]; then
            printf "${C_YELLOW_BOLD}  ⚠ Original Issue:${RESET} ${FILE_REASONS[$i]}\n"
            break
        fi
    done
    
    for i in "${!FOLDER_PATHS[@]}"; do
        if [[ "${FOLDER_PATHS[$i]}" == "$path" ]]; then
            printf "${C_YELLOW_BOLD}  ⚠ Original Issue:${RESET} ${FOLDER_REASONS[$i]}\n"
            break
        fi
    done
    
    echo ""
}

# ============================================================================
# MAIN EXECUTION
# ============================================================================

main() {
    show_banner
    
    printf "${C_WHITE}${BOLD}  Initializing ULTRA-DEEP diagnostic scan...${RESET}\n"
    printf "${C_GRAY}  Target: $SCAN_DIR${RESET}\n"
    printf "${C_GRAY}  Scan Depth: MAXIMUM (No Limits)${RESET}\n"
    printf "${C_GRAY}  Detection Methods: 5 Advanced Phases${RESET}\n"
    echo ""
    
    # Run detection in background
    detect_corruptions &
    local scan_pid=$!
    
    show_scanning_animation $scan_pid
    wait $scan_pid
    
    display_results
}

# ============================================================================
# COMMAND HANDLER
# ============================================================================

if [[ "$1" == "fix" ]]; then
    # Parse fix command
    shift
    name=""
    path=""
    
    for arg in "$@"; do
        if [[ "$arg" == path=* ]]; then
            path="${arg#path=}"
        else
            name="$arg"
        fi
    done
    
    fix_item "$name" "$path"
else
    main
fi
