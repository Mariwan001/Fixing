#!/bin/bash

# ============================================================================
# FIXING - Ultra-Powerful Advanced System Diagnostic & Repair Tool
# Creator: Mariwan Iraj
# ============================================================================

VERSION="1.0.0"
SCAN_DIR="$HOME"

# ============================================================================
# COLOR DEFINITIONS & UI ELEMENTS
# ============================================================================

RESET='\033[0m'
BOLD='\033[1m'
C_BLUE_BOLD='\033[1;38;5;39m'
C_RED_BOLD='\033[1;38;5;196m'
C_YELLOW_BOLD='\033[1;38;5;226m'
C_GREEN_BOLD='\033[1;38;5;46m'
C_CYAN='\033[38;5;51m'
C_PURPLE='\033[38;5;141m'
C_GRAY='\033[38;5;240m'
C_WHITE='\033[38;5;255m'
C_ORANGE='\033[38;5;208m'

# ============================================================================
# UI RENDERING FUNCTIONS
# ============================================================================

clear_screen() {
    clear
    tput cup 0 0
}

get_terminal_width() {
    tput cols
}

draw_line() {
    local char="${1:-─}"
    local width=$(get_terminal_width)
    printf "${C_CYAN}${BOLD}"
    printf "${char}%.0s" $(seq 1 $width)
    printf "${RESET}\n"
}

draw_double_line() {
    draw_line "═"
}

center_text() {
    local text="$1"
    local width=$(get_terminal_width)
    local text_length=${#text}
    local padding=$(( (width - text_length) / 2 ))
    printf "%${padding}s%s\n" "" "$text"
}

show_banner() {
    clear_screen
    
    echo ""
    draw_double_line
    echo ""
    
    printf "${C_CYAN}${BOLD}"
    center_text "███████╗██╗██╗  ██╗██╗███╗   ██╗ ██████╗ "
    center_text "██╔════╝██║╚██╗██╔╝██║████╗  ██║██╔════╝ "
    center_text "█████╗  ██║ ╚███╔╝ ██║██╔██╗ ██║██║  ███╗"
    center_text "██╔══╝  ██║ ██╔██╗ ██║██║╚██╗██║██║   ██║"
    center_text "██║     ██║██╔╝ ██╗██║██║ ╚████║╚██████╔╝"
    center_text "╚═╝     ╚═╝╚═╝  ╚═╝╚═╝╚═╝  ╚═══╝ ╚═════╝ "
    printf "${RESET}\n"
    
    printf "${C_PURPLE}${BOLD}"
    center_text "Advanced System Diagnostic & Repair Tool"
    printf "${RESET}\n"
    
    printf "${C_GRAY}"
    center_text "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    printf "${RESET}\n"
    
    printf "${C_WHITE}${BOLD}"
    center_text "Creator || Mariwan Iraj"
    printf "${RESET}\n"
    
    printf "${C_GRAY}"
    center_text "v${VERSION}"
    printf "${RESET}\n"
    
    echo ""
    draw_double_line
    echo ""
    
    sleep 1.5
}

# ============================================================================
# CORRUPTION DETECTION - DIRECT AND POWERFUL
# ============================================================================

declare -a CORRUPTED_FILES=()
declare -a CORRUPTED_FOLDERS=()
declare -a FILE_PATHS=()
declare -a FOLDER_PATHS=()
declare -a FILE_REASONS=()
declare -a FOLDER_REASONS=()
declare -a FILE_SOLUTIONS=()
declare -a FOLDER_SOLUTIONS=()

scan_progress() {
    local count="$1"
    printf "\r${C_CYAN}  [●]${RESET} ${C_WHITE}Scanning... ${C_GRAY}[$count items checked]${RESET}"
}

detect_corruptions() {
    local item_count=0
    
    printf "${C_CYAN}${BOLD}  [▶]${RESET} ${C_WHITE}Phase 1: Scanning for broken symlinks...${RESET}\n"
    
    # DIRECT METHOD: Scan every single file/directory
    find "$SCAN_DIR" 2>/dev/null | while IFS= read -r item; do
        ((item_count++))
        
        # Update progress every 100 items
        if (( item_count % 100 == 0 )); then
            scan_progress "$item_count"
        fi
        
        # Check if it's a broken symlink - MULTIPLE METHODS
        if [[ -L "$item" ]]; then
            # Method 1: Test if target exists
            if [[ ! -e "$item" ]]; then
                echo "BROKEN_LINK|$item"
            fi
        elif [[ -h "$item" ]]; then
            # Method 2: Alternative symlink check
            if ! test -e "$item"; then
                echo "BROKEN_LINK|$item"
            fi
        fi
        
        # Check if it's a zero-byte config file
        if [[ -f "$item" ]] && [[ ! -s "$item" ]]; then
            case "${item##*.}" in
                conf|config|json|xml|ini|yml|yaml|cfg)
                    echo "ZERO_FILE|$item"
                    ;;
            esac
        fi
        
        # Check if file has permission issues
        if [[ -f "$item" ]]; then
            if ! test -r "$item" 2>/dev/null; then
                echo "NO_READ|$item"
            fi
        fi
        
        # Check if directory has permission issues
        if [[ -d "$item" ]]; then
            if ! test -x "$item" 2>/dev/null; then
                echo "NO_EXEC|$item"
            fi
        fi
        
    done > /tmp/fixing_scan_results.txt
    
    printf "\r${C_GREEN_BOLD}  [✓]${RESET} ${C_WHITE}Scan complete! Processing results...${RESET}                    \n"
    
    # Process results
    if [[ -f /tmp/fixing_scan_results.txt ]]; then
        while IFS='|' read -r issue_type item_path; do
            case "$issue_type" in
                BROKEN_LINK)
                    CORRUPTED_FILES+=("$(basename "$item_path")")
                    FILE_PATHS+=("$item_path")
                    FILE_REASONS+=("Broken symbolic link - target does not exist")
                    FILE_SOLUTIONS+=("Remove: rm '$item_path'")
                    ;;
                ZERO_FILE)
                    CORRUPTED_FILES+=("$(basename "$item_path")")
                    FILE_PATHS+=("$item_path")
                    FILE_REASONS+=("Zero-byte configuration file (empty)")
                    FILE_SOLUTIONS+=("Restore or regenerate config file")
                    ;;
                NO_READ)
                    CORRUPTED_FILES+=("$(basename "$item_path")")
                    FILE_PATHS+=("$item_path")
                    FILE_REASONS+=("Permission denied - not readable")
                    FILE_SOLUTIONS+=("Fix: sudo chmod 644 '$item_path'")
                    ;;
                NO_EXEC)
                    CORRUPTED_FOLDERS+=("$(basename "$item_path")")
                    FOLDER_PATHS+=("$item_path")
                    FOLDER_REASONS+=("Directory not accessible")
                    FOLDER_SOLUTIONS+=("Fix: sudo chmod 755 '$item_path'")
                    ;;
            esac
        done < /tmp/fixing_scan_results.txt
        
        rm -f /tmp/fixing_scan_results.txt
    fi
}

# ============================================================================
# DISPLAY FUNCTIONS
# ============================================================================

display_results() {
    echo ""
    printf "${C_CYAN}${BOLD}╔══════════════════════════════════════════════════════════════════════════╗${RESET}\n"
    printf "${C_CYAN}${BOLD}║                         DIAGNOSTIC RESULTS                               ║${RESET}\n"
    printf "${C_CYAN}${BOLD}╚══════════════════════════════════════════════════════════════════════════╝${RESET}\n"
    echo ""
    
    local total_issues=$((${#CORRUPTED_FILES[@]} + ${#CORRUPTED_FOLDERS[@]}))
    
    if [[ $total_issues -eq 0 ]]; then
        echo ""
        printf "${C_GREEN_BOLD}${BOLD}"
        center_text "✓ No corrupted files and folders found"
        printf "${RESET}\n"
        echo ""
        printf "${C_GRAY}"
        center_text "System integrity: OPTIMAL"
        printf "${RESET}\n"
        echo ""
        return
    fi
    
    printf "${C_ORANGE}${BOLD}  → Found ${total_issues} issue(s)${RESET}\n\n"
    
    # Display corrupted files
    if [[ ${#CORRUPTED_FILES[@]} -gt 0 ]]; then
        printf "${C_WHITE}${BOLD}  Corrupted Files:${RESET}\n"
        draw_line "─"
        
        for i in "${!CORRUPTED_FILES[@]}"; do
            printf "\n  ${C_BLUE_BOLD}${BOLD}FILE: ${CORRUPTED_FILES[$i]}${RESET}\n"
            printf "  ${C_GRAY}└─ Path: ${FILE_PATHS[$i]}${RESET}\n"
            printf "     ${C_YELLOW_BOLD}${BOLD}⚠ Reason:${RESET} ${C_YELLOW_BOLD}${FILE_REASONS[$i]}${RESET}\n"
            printf "     ${C_GREEN_BOLD}${BOLD}✓ Solution:${RESET} ${C_GREEN_BOLD}${FILE_SOLUTIONS[$i]}${RESET}\n"
        done
        echo ""
    fi
    
    # Display corrupted folders
    if [[ ${#CORRUPTED_FOLDERS[@]} -gt 0 ]]; then
        printf "${C_WHITE}${BOLD}  Corrupted Folders:${RESET}\n"
        draw_line "─"
        
        for i in "${!CORRUPTED_FOLDERS[@]}"; do
            printf "\n  ${C_RED_BOLD}${BOLD}FOLDER: ${CORRUPTED_FOLDERS[$i]}${RESET}\n"
            printf "  ${C_GRAY}└─ Path: ${FOLDER_PATHS[$i]}${RESET}\n"
            printf "     ${C_YELLOW_BOLD}${BOLD}⚠ Reason:${RESET} ${C_YELLOW_BOLD}${FOLDER_REASONS[$i]}${RESET}\n"
            printf "     ${C_GREEN_BOLD}${BOLD}✓ Solution:${RESET} ${C_GREEN_BOLD}${FOLDER_SOLUTIONS[$i]}${RESET}\n"
        done
        echo ""
    fi
    
    echo ""
    draw_line "─"
    printf "\n${C_PURPLE}${BOLD}  TIP:${RESET} Use ${C_CYAN}fixing fix [name] path=[path]${RESET} to auto-repair\n"
    echo ""
}

# ============================================================================
# AUTO-FIX FUNCTION
# ============================================================================

fix_item() {
    local name="$1"
    local path="$2"
    
    if [[ -z "$name" ]] || [[ -z "$path" ]]; then
        printf "${C_RED_BOLD}Error: Invalid syntax. Use: fixing fix [name] path=[path]${RESET}\n"
        return 1
    fi
    
    echo ""
    printf "${C_CYAN}${BOLD}╔══════════════════════════════════════════════════════════════════════════╗${RESET}\n"
    printf "${C_CYAN}${BOLD}║                         REPAIR PROCESS                                   ║${RESET}\n"
    printf "${C_CYAN}${BOLD}╚══════════════════════════════════════════════════════════════════════════╝${RESET}\n"
    echo ""
    
    printf "${C_WHITE}  Target: ${C_CYAN}${name}${RESET}\n"
    printf "${C_WHITE}  Path: ${C_GRAY}${path}${RESET}\n"
    echo ""
    
    # Actual fix operations
    if [[ -L "$path" ]] && [[ ! -e "$path" ]]; then
        printf "  ${C_CYAN}▶${RESET} Removing broken symlink..."
        rm -f "$path" 2>/dev/null
        if [[ $? -eq 0 ]]; then
            printf " ${C_GREEN_BOLD}✓${RESET}\n"
        else
            printf " ${C_RED_BOLD}✗${RESET}\n"
        fi
    fi
    
    echo ""
    printf "${C_GREEN_BOLD}${BOLD}  ✓ REPAIR COMPLETED${RESET}\n"
    echo ""
}

# ============================================================================
# MAIN EXECUTION
# ============================================================================

main() {
    show_banner
    
    printf "${C_WHITE}${BOLD}  Initializing ULTRA-DEEP diagnostic scan...${RESET}\n"
    printf "${C_GRAY}  Target: $SCAN_DIR${RESET}\n"
    printf "${C_GRAY}  Mode: MAXIMUM DEPTH - NO LIMITS${RESET}\n"
    echo ""
    
    detect_corruptions
    display_results
}

# ============================================================================
# COMMAND HANDLER
# ============================================================================

if [[ "$1" == "fix" ]]; then
    shift
    name=""
    path=""
    
    for arg in "$@"; do
        if [[ "$arg" == path=* ]]; then
            path="${arg#path=}"
        else
            name="$arg"
        fi
    done
    
    fix_item "$name" "$path"
else
    main
fi
