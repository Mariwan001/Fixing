#!/bin/bash

# ============================================================================
# FIXING - Advanced System Diagnostic & Repair Tool
# Creator: Mariwan Iraj
# Version: 1.0.0
# ============================================================================

# Color Definitions
RESET='\033[0m'
BOLD='\033[1m'
DIM='\033[2m'

# Custom Colors
BLUE_BOLD='\033[1;38;5;33m'
RED_BOLD='\033[1;38;5;196m'
YELLOW_BOLD='\033[1;38;5;226m'
GREEN_BOLD='\033[1;38;5;46m'
CYAN='\033[38;5;51m'
PURPLE='\033[38;5;141m'
ORANGE='\033[38;5;208m'
GRAY='\033[38;5;240m'
WHITE_BOLD='\033[1;97m'

# UI Elements
CHECKMARK="✓"
CROSS="✗"
ARROW="→"
GEAR="⚙"
SEARCH="🔍"
WARNING="⚠"

# Terminal dimensions
TERM_WIDTH=$(tput cols)

# ============================================================================
# UI FUNCTIONS
# ============================================================================

print_center() {
    local text="$1"
    local color="$2"
    local padding=$(( (TERM_WIDTH - ${#text}) / 2 ))
    printf "%${padding}s${color}${BOLD}%s${RESET}\n" "" "$text"
}

print_line() {
    local char="${1:-─}"
    printf "${GRAY}"
    printf '%*s\n' "$TERM_WIDTH" | tr ' ' "$char"
    printf "${RESET}"
}

print_double_line() {
    printf "${CYAN}"
    printf '%*s\n' "$TERM_WIDTH" | tr ' ' '═'
    printf "${RESET}"
}

draw_box() {
    local text="$1"
    local color="$2"
    local text_length=${#text}
    local box_width=$((text_length + 4))
    local padding=$(( (TERM_WIDTH - box_width) / 2 ))
    
    printf "%${padding}s${color}╔"
    printf '%*s' "$((text_length + 2))" | tr ' ' '═'
    printf "╗${RESET}\n"
    
    printf "%${padding}s${color}║${RESET} ${BOLD}%s${RESET} ${color}║${RESET}\n" "" "$text"
    
    printf "%${padding}s${color}╚"
    printf '%*s' "$((text_length + 2))" | tr ' ' '═'
    printf "╝${RESET}\n"
}

animate_dots() {
    local duration=$1
    local message="$2"
    local end_time=$((SECONDS + duration))
    
    while [ $SECONDS -lt $end_time ]; do
        for dots in "   " ".  " ".. " "..."; do
            printf "\r${CYAN}${message}${dots}${RESET}"
            sleep 0.2
        done
    done
    printf "\r%*s\r" "$TERM_WIDTH" ""
}

show_banner() {
    clear
    echo ""
    print_double_line
    echo ""
    
    # ASCII Art Title
    print_center "███████╗██╗██╗  ██╗██╗███╗   ██╗ ██████╗ " "$CYAN"
    print_center "██╔════╝██║╚██╗██╔╝██║████╗  ██║██╔════╝ " "$CYAN"
    print_center "█████╗  ██║ ╚███╔╝ ██║██╔██╗ ██║██║  ███╗" "$CYAN"
    print_center "██╔══╝  ██║ ██╔██╗ ██║██║╚██╗██║██║   ██║" "$CYAN"
    print_center "██║     ██║██╔╝ ██╗██║██║ ╚████║╚██████╔╝" "$CYAN"
    print_center "╚═╝     ╚═╝╚═╝  ╚═╝╚═╝╚═╝  ╚═══╝ ╚═════╝ " "$CYAN"
    
    echo ""
    print_center "Advanced System Diagnostic & Repair Tool" "$PURPLE"
    echo ""
    print_center "Creator || Mariwan Iraj" "$ORANGE"
    echo ""
    print_double_line
    echo ""
    sleep 1.5
}

show_progress_bar() {
    local current=$1
    local total=$2
    local width=50
    local percentage=$((current * 100 / total))
    local filled=$((width * current / total))
    local empty=$((width - filled))
    
    printf "\r${CYAN}[${RESET}"
    printf "%${filled}s" | tr ' ' '█'
    printf "%${empty}s" | tr ' ' '░'
    printf "${CYAN}]${RESET} ${WHITE_BOLD}%3d%%${RESET}" "$percentage"
}

# ============================================================================
# CORRUPTION DETECTION FUNCTIONS
# ============================================================================

check_file_corruption() {
    local file="$1"
    local corruption_reason=""
    local is_corrupted=0
    
    # Check if file is readable
    if [ ! -r "$file" ]; then
        corruption_reason="Permission denied - File is not readable"
        is_corrupted=1
    # Check for zero-byte files
    elif [ -f "$file" ] && [ ! -s "$file" ] && [[ "$file" != *.empty ]] && [[ "$file" != .gitkeep ]]; then
        corruption_reason="Zero-byte file detected - File may be truncated"
        is_corrupted=1
    # Check for broken symlinks
    elif [ -L "$file" ] && [ ! -e "$file" ]; then
        corruption_reason="Broken symbolic link - Target does not exist"
        is_corrupted=1
    # Check file integrity for specific types
    elif [[ "$file" =~ \.(jpg|jpeg|png|gif)$ ]]; then
        if ! file "$file" 2>/dev/null | grep -iq "image"; then
            corruption_reason="Invalid image format - File header corrupted"
            is_corrupted=1
        fi
    elif [[ "$file" =~ \.(zip|tar|gz)$ ]]; then
        if ! file "$file" 2>/dev/null | grep -iq "archive\|compressed"; then
            corruption_reason="Invalid archive format - Compression header damaged"
            is_corrupted=1
        fi
    elif [[ "$file" =~ \.(pdf)$ ]]; then
        if ! file "$file" 2>/dev/null | grep -iq "PDF"; then
            corruption_reason="Invalid PDF format - Document structure corrupted"
            is_corrupted=1
        fi
    fi
    
    echo "$is_corrupted|$corruption_reason"
}

check_directory_corruption() {
    local dir="$1"
    local corruption_reason=""
    local is_corrupted=0
    
    # Check if directory is accessible
    if [ ! -r "$dir" ] || [ ! -x "$dir" ]; then
        corruption_reason="Access denied - Insufficient permissions"
        is_corrupted=1
    # Check for permission anomalies
    elif [ -d "$dir" ]; then
        local perms=$(stat -c %a "$dir" 2>/dev/null || stat -f %A "$dir" 2>/dev/null)
        if [ -z "$perms" ] || [ "$perms" = "000" ]; then
            corruption_reason="Permission corruption - No access rights set"
            is_corrupted=1
        fi
    fi
    
    echo "$is_corrupted|$corruption_reason"
}

get_fix_solution() {
    local reason="$1"
    local solution=""
    
    case "$reason" in
        *"Permission denied"*|*"Access denied"*)
            solution="Run: sudo chmod 644 [file] or sudo chmod 755 [directory]"
            ;;
        *"Zero-byte"*)
            solution="Restore from backup or remove file: rm [file]"
            ;;
        *"Broken symbolic link"*)
            solution="Remove broken link: rm [file] then recreate: ln -s [target] [link]"
            ;;
        *"Invalid image format"*)
            solution="Use image recovery tool or restore from backup"
            ;;
        *"Invalid archive format"*)
            solution="Re-download archive or extract partial data with recovery tools"
            ;;
        *"Invalid PDF format"*)
            solution="Use PDF repair tool (e.g., pdftk) or restore from backup"
            ;;
        *)
            solution="Manual inspection required - Check file integrity and permissions"
            ;;
    esac
    
    echo "$solution"
}

# ============================================================================
# REPAIR FUNCTIONS
# ============================================================================

repair_item() {
    local item="$1"
    local item_type="$2"
    local reason="$3"
    
    echo ""
    print_line "─"
    print_center "REPAIR PROCESS INITIATED" "$CYAN"
    print_line "─"
    echo ""
    
    printf "${WHITE_BOLD}Target:${RESET} %s\n" "$item"
    printf "${WHITE_BOLD}Type:${RESET}   %s\n" "$item_type"
    printf "${YELLOW_BOLD}Issue:${RESET}  %s\n" "$reason"
    echo ""
    
    # Simulated repair process with progress
    local steps=("Analyzing structure" "Creating backup" "Applying fix" "Verifying integrity" "Finalizing")
    local total_steps=${#steps[@]}
    
    for i in "${!steps[@]}"; do
        printf "${CYAN}${GEAR}${RESET} ${steps[$i]}...\n"
        show_progress_bar $((i + 1)) $total_steps
        sleep 0.8
    done
    
    echo -e "\n"
    
    # Apply actual fix based on issue type
    local fix_success=1
    
    if [[ "$reason" =~ "Permission" ]]; then
        if [ "$item_type" = "FILE" ]; then
            chmod 644 "$item" 2>/dev/null && fix_success=0
        else
            chmod 755 "$item" 2>/dev/null && fix_success=0
        fi
    elif [[ "$reason" =~ "Broken symbolic link" ]]; then
        rm "$item" 2>/dev/null && fix_success=0
    fi
    
    # Show result
    if [ $fix_success -eq 0 ]; then
        draw_box "${CHECKMARK} REPAIR COMPLETED SUCCESSFULLY" "$GREEN_BOLD"
    else
        draw_box "${WARNING} MANUAL INTERVENTION REQUIRED" "$YELLOW_BOLD"
    fi
    
    echo ""
    printf "${WHITE_BOLD}Corruption Cause:${RESET}\n"
    printf "${YELLOW_BOLD}%s${RESET}\n" "$reason"
    echo ""
    print_line "─"
}

# ============================================================================
# SCANNING FUNCTIONS
# ============================================================================

scan_system() {
    local scan_path="${1:-$HOME}"
    local corrupted_files=()
    local corrupted_dirs=()
    local file_reasons=()
    local dir_reasons=()
    
    echo ""
    printf "${CYAN}${SEARCH}${RESET} ${WHITE_BOLD}Initializing deep system scan...${RESET}\n"
    echo ""
    animate_dots 2 "Preparing scan engine"
    
    printf "${CYAN}${ARROW}${RESET} Scanning: ${WHITE_BOLD}%s${RESET}\n\n" "$scan_path"
    
    local total_items=$(find "$scan_path" -maxdepth 3 2>/dev/null | wc -l)
    local current=0
    
    # Scan files and directories
    while IFS= read -r item; do
        ((current++))
        
        if [ $((current % 5)) -eq 0 ]; then
            show_progress_bar "$current" "$total_items"
        fi
        
        if [ -f "$item" ] || [ -L "$item" ]; then
            local result=$(check_file_corruption "$item")
            local is_corrupted=$(echo "$result" | cut -d'|' -f1)
            local reason=$(echo "$result" | cut -d'|' -f2)
            
            if [ "$is_corrupted" -eq 1 ] && [ -n "$reason" ]; then
                corrupted_files+=("$item")
                file_reasons+=("$reason")
            fi
        elif [ -d "$item" ]; then
            local result=$(check_directory_corruption "$item")
            local is_corrupted=$(echo "$result" | cut -d'|' -f1)
            local reason=$(echo "$result" | cut -d'|' -f2)
            
            if [ "$is_corrupted" -eq 1 ] && [ -n "$reason" ]; then
                corrupted_dirs+=("$item")
                dir_reasons+=("$reason")
            fi
        fi
    done < <(find "$scan_path" -maxdepth 3 2>/dev/null)
    
    show_progress_bar "$total_items" "$total_items"
    echo -e "\n"
    
    # Display results
    print_double_line
    echo ""
    
    if [ ${#corrupted_files[@]} -eq 0 ] && [ ${#corrupted_dirs[@]} -eq 0 ]; then
        print_center "NO CORRUPTED FILES AND FOLDERS FOUND" "$GREEN_BOLD"
        echo ""
        print_double_line
        return 0
    fi
    
    print_center "CORRUPTION REPORT" "$ORANGE"
    echo ""
    print_line "─"
    echo ""
    
    # Display corrupted files
    if [ ${#corrupted_files[@]} -gt 0 ]; then
        printf "${WHITE_BOLD}CORRUPTED FILES [%d]:${RESET}\n\n" "${#corrupted_files[@]}"
        
        for i in "${!corrupted_files[@]}"; do
            local filename=$(basename "${corrupted_files[$i]}")
            local filepath="${corrupted_files[$i]}"
            local solution=$(get_fix_solution "${file_reasons[$i]}")
            
            printf "${BLUE_BOLD}%-40s${RESET} ${GRAY}${ARROW}${RESET} ${DIM}%s${RESET}\n" \
                   "$filename" "$filepath"
            printf "  ${YELLOW_BOLD}Reason:${RESET}   %s\n" "${file_reasons[$i]}"
            printf "  ${GREEN_BOLD}Solution:${RESET} %s\n" "$solution"
            echo ""
        done
    fi
    
    # Display corrupted directories
    if [ ${#corrupted_dirs[@]} -gt 0 ]; then
        printf "${WHITE_BOLD}CORRUPTED FOLDERS [%d]:${RESET}\n\n" "${#corrupted_dirs[@]}"
        
        for i in "${!corrupted_dirs[@]}"; do
            local dirname=$(basename "${corrupted_dirs[$i]}")
            local dirpath="${corrupted_dirs[$i]}"
            local solution=$(get_fix_solution "${dir_reasons[$i]}")
            
            printf "${RED_BOLD}%-40s${RESET} ${GRAY}${ARROW}${RESET} ${DIM}%s${RESET}\n" \
                   "$dirname" "$dirpath"
            printf "  ${YELLOW_BOLD}Reason:${RESET}   
